## Informalean
In this project we train a language model LoRA to translate theorem statements formalized in Lean to plain English. We trained against instruction-tuned Qwen 2.5 models of two sizes, 0.5B and 7B. The 7B model was already reasonably accurate at translating the statements and the finetuning mostly imparts the style of the dataset, but the 0.5B model sees significant subjective gains in task accuracy. The trained artifact is available at https://huggingface.co/sglasman/informalean.
### Preprocessing 
We use the [Herald dataset of formalized/natural language pairs](https://huggingface.co/datasets/FrenzyMath/Herald_statements). We filter out a number of examples whose informal statement is in Chinese, drop theorem names in order to train pure Lean translation rather than inference from theorem names, and use MinHash/LSH to group the statements by similarity to avoid leakage across the dataset splits. 
### Training
There are many duplicate formal statements with slightly different informalizations in the dataset; in order not to overtrain on overrepresented examples, we use a custom sampler weighting each example inversely by its number of duplicates. Our final pass trains a rank 16 LoRA for 20,000 steps.
### Try it yourself
Clone the repo and, with `uv` installed, run: 
`uv run -- python -m informalean.train.statements.train --config-name [cloud|local]`
Or tweak the config files (`/config/cloud.yaml`, `/config/local.yaml`) to your preference.
### Examples
Here are a few statements from the validation set together with the informalizations produced by the vanilla Qwen2.5-0.5B model, the informalizations produced by the same model with the LoRA attached, and the reference informalizations in the dataset. Inspection shows that the statement generated by the vanilla model is often long-winded and confused, whereas the statements generated with the LoRA are usually faithful to the formal statement in mathematical content.
<details>
<summary>Show table </summary>

| Formal statement | Without LoRA | With LoRA | Reference |
| --- | --- | --- | --- |
| theorem [CategoryTheory.Category.{u_2 : u_1} C] [CategoryTheory.HasShift C ‚Ñ§] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Preadditive C] [inst_4 (n : ‚Ñ§) : (CategoryTheory.shiftFunctor C n).Additive] [CategoryTheory.Pretriangulated C] (T : CategoryTheory.Pretriangulated.Triangle C·µí·µñ), T ‚àà CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C ‚Üî T.rotate ‚àà CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C | The theorem states that for a category  C  equipped with the structure of a category of sets, a shift functor  shiftFunctor_C(n)  from  C  to its additive subcategory of integers  ‚Ñ§ , and a preadditive category  C , an object  T  in  C  is distinguished if and only if  T  rotates under the functor  shiftFunctor_C  into an object in  C 's opposite category  C·µí·µñ . | For a triangle T in the opposite category of triangles over a pretriangulated category C, show that T is distinguished if and only if its rotation is also distinguished. | For a triangle  T  in the opposite category  C·µí·µñ , show that  T  is a distinguished triangle in  C  if and only if its rotation  T.rotate  is a distinguished triangle in  C .
|theorem [LieRing L] [Field K] [LieAlgebra K L] [FiniteDimensional K L] {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [LieAlgebra.IsKilling K L] [LieModule.IsTriangularizable K (‚Ü•H) L] [PerfectField K] {Œ± : LieModule.Weight K (‚Ü•H) L} {e f : L} : e ‚àà LieAlgebra.rootSpace H ‚áëŒ± ‚Üí f ‚àà LieAlgebra.rootSpace H (-‚áëŒ±) ‚Üí ‚ÅÖe, f‚ÅÜ = ((killingForm K L) e) f ‚Ä¢ ‚Üë((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (‚Ü•H) L Œ±)) | The theorem states that for a Lie ring  ùìõ , a field  ùïÇ , a Lie algebra  ùí¶  over  ùïÇ , a finite-dimensional vector space  ùïÇ ùìõ , and a perfect field  ùïÇ , the following holds:<br><br>1. Let  ùìó  be a Cartan subalgebra of  ùí¶ ùìõ .<br>2. Assume  ùìó  is an irreducible Cartan subalgebra.<br>3. Consider the Lie algebra  ùí¶ ùìõ  as a Lie module over  ùïÇ .<br>4. The weight  Œ±  of  ùìó  in  ùí¶ ùìõ  satisfies the condition  LieSubalgebra}(K, L) .<br><br>Given these conditions, it follows that there exists a Lie subalgebra  ùìó'  of  ùí¶ ùìõ  such that  ùìó'  is also a Cartan subalgebra of  ùí¶ ùìõ , and the root spaces of  ùìó'  correspond to the roots of  ùìó  in  ùí¶ ùìõ.|Theorem: Let  K  be a perfect field of characteristic zero, and let  L  be a finite-dimensional vector space over  K  with a Cartan subalgebra  H , where the root system is given by  Œ± . For any two elements  e, f ‚àà L  such that  e  belongs to the root space associated with  Œ±  and  f  belongs to the opposite root space associated with the negation of  Œ± , show that the commutator  [e, f]  in the Lie algebra  L  is equal to the product of the Killing form of  L  at  e  and  f , and the adjoint action of the inverse Cartan involution on the linear part of the Killing form of  L  at  f .|For any weight Œ± in the weight space of a Lie algebra L over a field K, with Cartan subalgebra H, and for any e, f ‚àà L such that e belongs to the root space rootSpace_H(Œ±) and f belongs to the root space rootSpace_H(-Œ±), show that the Lie bracket ‚å© e, f ‚å™ is equal to the killing form killingForm_K^L(e, f) scalar multiplied by the result of applying the symmetric part of the Cartan equivalence to Œ±, i.e., ‚å© e, f ‚å™ = killingForm_K^L(e, f) ¬∑ (cartanEquivDual_H)‚Åª¬π(Œ±).|
|theorem [CommSemiring R] [AddCommMonoid N‚ÇÇ] [Module R N‚ÇÇ] [Semiring R‚ÇÅ] [Semiring R‚ÇÇ] [Semiring S‚ÇÅ] [Semiring S‚ÇÇ] [Module S‚ÇÅ N‚ÇÇ] [Module S‚ÇÇ N‚ÇÇ] [SMulCommClass S‚ÇÅ R N‚ÇÇ] [SMulCommClass S‚ÇÇ R N‚ÇÇ] [SMulCommClass S‚ÇÇ S‚ÇÅ N‚ÇÇ] (œÉ‚ÇÅ : R‚ÇÅ ‚Üí+* S‚ÇÅ) (œÉ‚ÇÇ : R‚ÇÇ ‚Üí+* S‚ÇÇ) [Fintype n] [Fintype m] [DecidableEq n] [DecidableEq m] (M : Matrix n m N‚ÇÇ) (i : n) (j : m) : (((toLinearMap‚Çõ‚Çó‚ÇÇ' R œÉ‚ÇÅ œÉ‚ÇÇ) M) ((LinearMap.stdBasis R‚ÇÅ (fun x => R‚ÇÅ) i) 1)) ((LinearMap.stdBasis R‚ÇÇ (fun x => R‚ÇÇ) j) 1) = M i j|The theorem formalizes the equality of two linear maps defined over a commutative semiring  ‚Ñù , where the coefficients are elements from two different modules  ‚Ñï‚ÇÇ . The theorem states that for matrices  M  with entries in  ‚Ñï‚ÇÇ :<br><br>\\[<br>((toLinearMap}_{stdBasis}}^{comm}} (Matrix}_{n, m}^{N}‚ÇÇ}(M)))(LinearMapStdBasis}_{stdBasis}}^{comm}} (Fun}_{R}‚ÇÅ}^{n}(x \\mapsto R}‚ÇÅ)))‚ÇÅ) <br>((LinearMapStdBasis}_{stdBasis}}^{comm}} (Fun}_{R}‚ÇÇ}^{m}(x \\mapsto R}‚ÇÇ}))‚ÇÅ) = M_i^j,<br>\\]<br><br>where  toLinearMap_{stdBasis}^{comm}  is a function mapping from  Matrix_{n, m}^{N}‚ÇÇ}  to  LinearMapStdBasis_{stdBasis}^{comm} , and  LinearMapStdBasis_{stdBasis}^{comm}  is a function mapping from  Fun_{R}‚ÇÅ^{n}(x \\mapsto R}‚ÇÅ  to  LinearMapStdBasis_{stdBasis}^{comm}  and from  Fun_{R}‚ÇÇ^{m}(x \\mapsto R}‚ÇÇ  to  LinearMapStdBasis_{stdBasis}^{comm}.|Theorem: For any matrix  M  of size  n √ó m  over the ring  R , and for any indices  i, j , the linear map induced by the standard basis on  R‚ÇÅ  at index  i  is equal to the entry in the  i -th row and  j -th column of  M . That is, if  M  is a matrix with entries in  R , then the linear map associated with the standard basis on  R‚ÇÅ  at index  i  is equal to the  i -th row and  j -th column of  M .|For any matrix M of size n √ó m over the ring N‚ÇÇ, and for any indices i in n and j in m, the application of the linear map represented by M on the standard basis element of R‚ÇÅ indexed by i and the standard basis element of R‚ÇÇ indexed by j yields the (i, j)-th entry of M. Specifically, this is expressed as Matrix.toLinearMap‚Çõ‚Çó‚ÇÇ'(M)(e_i^{R‚ÇÅ}, e_j^{R‚ÇÇ}) = M_{i, j}, where e_i^{R‚ÇÅ} and e_j^{R‚ÇÇ} denote the standard basis vectors in R‚ÇÅ and R‚ÇÇ respectively.|
|lemma [CommRing R] [IsDedekindDomain R] (v : HeightOneSpectrum R) (hv : Irreducible (Associates.mk v.asIdeal)) (hlt : v.asIdeal ^ 2 < v.asIdeal) (œÄ : R) (mem : 1 ‚â§ (Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {œÄ})).factors) (nmem : (Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {œÄ})).factors < 2) (hœÄ : Associates.mk (Ideal.span {œÄ}) ‚â† 0) : (Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {œÄ})).factors = 1|Given the conditions and definitions provided, we can derive the lemma step by step:<br><br>1. **Lemma Setup**: We need to show that the number of factors in the ideal span of  œÄ  is exactly one.<br><br>2. **Formal Definitions**:<br>  HeightOneSpectrum\(R\) : The height of a spectrum over a ring  R .<br>  Irreducible(A) : An element  A ‚àà R  is irreducible if it cannot be factored into non-unit elements.<br>  Associates(A) : The associates of an element  A  in a commutative ring  R , which consists of all units that divide  A .<br>  Ideal(I) : The ideal generated by an element  I  in a commutative ring  R .<br>  Ideal(I)^2 : The square of the ideal  I .<br>  Count(A, B) : The number of common factors between two ideals  A  and  B .<br><br>3. **Given Conditions**:<br>  v  is a height-one spectrum over  R .<br>  hv  is an irreducible element in  v  as its associates.<br>  hlt  is the condition that  v  is a principal ideal domain (PID).<br>  œÄ  is a generator of  v .<br>  nmem  is the count of factors of  œÄ  in  v .<br>  Associates(v) \\neq 0 : This implies there exists at least one unit in  v .<br><br>4. **Proof Steps**:<br> Since  v  is a height-one spectrum, it has a unique maximal ideal  m .<br> Let  œÄ ‚àà v  be a generator of  v .<br> Consider the ideal  I = œÄ^2 ‚äÜ v .<br> By the given condition  hlt ,  v  is a PID.<br> Therefore,  I  must also be a PID because any prime ideal in a PID is a maximal ideal.<br> In a PID, every ideal is principal, so  I = (œÄ) .<br>|For a commutative ring R that is also a Dedekind domain, let v be an element of the height one spectrum of R. Suppose v's associated ideal is irreducible and its square is less than v's associated ideal. Given œÄ ‚àà R, if the count of factors of the associated ideal of œÄ in the span of {œÄ} equals 1 but the count of factors of the associated ideal of œÄ in the span of {œÄ} is strictly less than 2, then show that the count of factors of the associated ideal of œÄ in the span of {œÄ} equals 1.|For any commutative ring R that is also a Dedekind domain, let v be an element of the height one spectrum of R, and suppose that the ideal associated with v is irreducible. Given that the square of the ideal associated with v is properly contained in the ideal itself, let œÄ be an element of R. If it holds that the count of the factorization of the ideal generated by {œÄ} within the ideal associated with v is at least 1, but strictly less than 2, and the ideal generated by {œÄ} is non-zero, then prove that the count of the factorization of the ideal generated by {œÄ} within the ideal associated with v is exactly 1.|
|lemma (m : MeasurableSpace Œ±) (Œº : Measure Œ±) [TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (s : Set Œ±) [DecidablePred fun x => x ‚àà s] (hs : MeasurableSet s) (hf : AEStronglyMeasurable f (Œº.restrict s)) (hg : AEStronglyMeasurable g (Œº.restrict s·∂ú)) (h : f =·∂†[ae (Œº.restrict s)] AEStronglyMeasurable.mk f hf) : ‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict s, s.piecewise f g x = s.piecewise (AEStronglyMeasurable.mk f hf) (AEStronglyMeasurable.mk g hg) x|Given the formal statement:<br><bbr>\\[ LEMMA (m: MeasurableSpace}_{Œ±}, Œº: Measure}_{Œ±}, [TopologicalSpace_{Œ≤}], f}: Œ± \\rightarrow Œ≤, g}: Œ± \\rightarrow Œ≤, s}: Set}_{Œ±}, [DecidablePred}(fun} x \\Rightarrow x \\in s})], (hs}: MeasurableSet}_{s}}), (hf}: AEStronglyMeasurable}_{f}}(u \\mapsto Œº}.restrict{s}}(u)), (hg}: AEStronglyMeasurable}_{g}}(v \\mapsto Œº}.restrict{s}}(v))), (h}): f} = ‚ü®}Œº}.restrict{s}}[measurable}(u)]  AEStronglyMeasurable}_{mk}}(f}, hf}), (‚àÄ}^{Œ±}} (x: Œ±})) \\frac{Œº}.restrict{s}}(x)}{setPiecewise}(f, g, x)} = ‚àÄ}^{Œ±}} (x: Œ±}) \\frac{Œº}.restrict{s}}(x)}{piecewise}(f, g, x)} x} \\]<br><br>The lemma is stated in a more formal and precise manner, ensuring clarity and correctness in mathematical expressions.|The given statement is a formalization of the assertion that for any measurable space (Œ±, m), a measure Œº on Œ±, and topological spaces Œ≤ and s, if s is a subset of Œ± with decidable membership, then there exists an almost everywhere equality between the piecewise functions f and g restricted to s under the measures induced by f and g respectively, where f is strongly measurable with respect to Œº restricted to s, g is strongly measurable with respect to the complement of Œº restricted to s^c, and f equals almost everywhere in s under the measure induced by f and g. This result is a specific instance of the more general theorem asserting the existence of a strong measurable function from a set to another, which can be found in the context of the `strongMeasure` lemma in the `measure_theory` library.|For a measurable space m on Œ±, a measure Œº on Œ±, and a topological space Œ≤, let f, g : Œ± ‚Üí Œ≤ be functions, s ‚äÜ Œ± be a set with a decidable predicate for membership, and assume s is a measurable set. Suppose further that f and g are almost everywhere strongly measurable with respect to the restricted measures Œº|_s and Œº|_{s^c}, respectively. Given that f is equal to the almost everywhere strongly measurable function constructed from f in the restricted measure Œº|_s almost everywhere, show that for Œº|_s-almost every x \\in Œ±, the piecewise function defined by f and g on s is equal to the piecewise function defined by their almost everywhere strongly measurable versions on s for x.|
</details>

### Further directions
Some ways this project could be improved or extended:

- Better eval. Current evaluation consists of ad hoc inspection of examples generated from the validation set. We could instead use a semantic similarity metric such as BERTScore to make evaluation consistent and automated.
- Better data. Upon inspection, many of the informal statements in the Herald dataset are incorrect. However, it's not really clear how this could be improved on without significant expense.
- Move beyond informalizing statements to informalizing proof steps. Here we would use LeanDojo's tracing technology to incorporate the Lean context into the language model's context, making fertile ground for training.
- Build a VSCode plugin around the model for in-context assistance when reading Lean code.
